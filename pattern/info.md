
单例模式:
    确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
    使用场景：
      ● 要求生成唯一序列号的环境；
      ● 在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，
      使用单例模式保持计数器的值，并确保是线程安全的；
      ● 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；
      ● 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。
      
工厂模式:
      定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
      Product为抽象产品类负责定义产品的共性，实现对事物最抽象的定义；
      Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。

          简单工厂模式：
          一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法

          多个工厂类：
          每个人种（具体的产品类）都对应了一个创建者，每个创建者独立负责创建对应的产品对象，非常符合单一职责原则

          代替单例模式：
          单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生产一个对象

          延迟初始化：
          ProductFactory负责产品类对象的创建工作，并且通过prMap变量产生一个缓存，对需要再次被重用的对象保留

          使用场景：jdbc连接数据库，硬件访问，降低对象的产生和销毁
          
抽象工厂模式（Abstract Factory Pattern）
        定义：为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。
        使用场景：
        一个对象族（或是一组没有任何关系的对象）都有相同的约束。
        涉及不同操作系统的时候，都可以考虑使用抽象工厂模式
        
模板方法模式（Template Method Pattern）

    定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    AbstractClass叫做抽象模板，它的方法分为两类：
    ● 基本方法
    基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。
    ● 模板方法
    可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。
    注意：　为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。
    具体模板：ConcreteClass1和ConcreteClass2属于具体模板，实现父类所定义的一个或多个抽象方法，
    也就是父类定义的基本方法在子类中得以实现
    使用场景：
    ● 多个子类有公有的方法，并且逻辑基本相同时。
    ● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
    ● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。
    
代理模式（Proxy Pattern）

      为其他对象提供一种代理以控制对这个对象的访问。
      ● Subject抽象主题角色
      抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。
      ● RealSubject具体主题角色
      也叫做被委托角色、被代理角色。它才是冤大头，是业务逻辑的具体执行者。
      ● Proxy代理主题角色
      也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，
      并且在真实主题角色处理完毕前后做预处理和善后处理工作。

      普通代理和强制代理：
      普通代理就是我们要知道代理的存在，也就是类似的GamePlayerProxy这个类的存在，然后才能访问；
      强制代理则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定的。
      普通代理：

      在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，
      真实的主题角色想怎么修改就怎么修改，对高层次的模块没有任何的影响，只要你实现了接口所对应的方法，
      该模式非常适合对扩展性要求较高的场合。

      强制代理：

      强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色
      。高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。

      动态代理：
      根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”。

      两条独立发展的线路。动态代理实现代理的职责，业务逻辑Subject实现相关的逻辑功能，两者之间没有必然的相互耦合的关系。
      通知Advice从另一个切面切入，最终在高层模块也就是Client进行耦合，完成逻辑的封装任务。

      动态代理调用过程示意图：

      动态代理的意图：横切面编程，在不改变我们已有代码结构的情况下增强或控制对象的行为。 
      首要条件：被代理的类必须要实现一个接口。
      
责任链模式

      使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。
      将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止
      抽象的处理者实现三个职责：
      一是定义一个请求的处理方法handleMessage，唯一对外开放的方法；
      二是定义一个链的编排方法setNext，设置下一个处理者；
      三是定义了具体的请求者必须实现的两个方法：定义自己能够处理的级别getHandlerLevel和具体的处理任务echo。
      注意事项：
      链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，
      在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。

策略模式（Strategy Pattern）

      定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。
      ● Context封装角色
      它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。
      ● Strategy抽象策略角色
      策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。
      
      ● ConcreteStrategy具体策略角色（多个）
      实现抽象策略中的操作，该类含有具体的算法。
      使用场景：
      ● 多个类只有在算法或行为上稍有不同的场景。
      ● 算法需要自由切换的场景。
      ● 需要屏蔽算法规则的场景。
      注意事项：具体策略数量超过4个，则需要考虑使用混合模式
 
策略模式扩展：策略枚举

      定义：
      ● 它是一个枚举。
      ● 它是一个浓缩了的策略模式的枚举。
      注意：
      受枚举类型的限制，每个枚举项都是public、final、static的，扩展性受到了一定的约束，
      因此在系统开发中，策略枚举一般担当不经常发生变化的角色。
      致命缺陷：
      所有的策略都需要暴露出去，由客户端决定使用哪一个策略。 
      
适配器模式（Adapter Pattern）

        将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

        ● Target目标角色
        该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口就是目标角色。
        ● Adaptee源角色
        你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，
        经过适配器角色的包装，它会成为一个崭新、靓丽的角色。
        ● Adapter适配器角色
        适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，
        它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。
        使用场景：
        你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。
        比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的。
        注意事项：
        详细设计阶段不要考虑使用适配器模式，使用主要场景为扩展应用中。
        对象适配器：
         对象适配器和类适配器的区别：
        类适配器是类间继承，对象适配器是对象的合成关系，也可以说是类的关联关系，这是两者的根本区别。
        （实际项目中对象适配器使用到的场景相对比较多）。
观察者模式（Observer Pattern）
        定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新


        ● Subject被观察者
        定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，
        仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。
        ● Observer观察者
        观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。
        ● ConcreteSubject具体的被观察者
        定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。
        ● ConcreteObserver具体的观察者
        每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。

        被观察者通用代码：
        使用场景：
        ● 关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。
        ● 事件多级触发场景。
        ● 跨系统的消息交换场景，如消息队列的处理机制。
        注意：
        ● 广播链的问题
        在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次）。
        ● 异步处理问题
        观察者比较多，而且处理时间比较长，采用异步处理来考虑线程安全和队列的问题。
